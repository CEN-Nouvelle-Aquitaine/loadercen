# -*- coding: utf-8 -*-
"""
/***************************************************************************
 LoaderCEN
                                 A QGIS plugin
 Blablabla
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-05-11
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Romain Montillet
        email                : r.montillet@cen-na.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import *
from qgis.PyQt.QtWidgets import *
from PyQt5 import *

from qgis.core import QgsFeatureRequest, QgsCoordinateTransform, QgsApplication, QgsVectorLayerJoinInfo, QgsRasterLayer, QgsVectorLayer, QgsProject, QgsFillSymbol, QgsSymbol, QgsRendererCategory, QgsCategorizedSymbolRenderer, QgsRandomColorRamp, QgsPointCloudLayer
from qgis.gui import *
from qgis.utils import *
import processing
from pathlib import Path
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .LoaderCEN_dialog import LoaderCENDialog
import os.path
import urllib
import tempfile
from urllib import request, parse
from PyQt5.QtXml import QDomDocument
import shutil
import platform
import socket
import re
import time


# Vérifier la connexion à internet
try:
    # Vérifier si l'utilisateur est connecté à internet en ouvrant une connexion avec un site web
    host = socket.gethostbyname("www.google.com")
    s = socket.create_connection((host, 80), 2)
    s.close()
except socket.error:
    # Afficher un message si l'utilisateur n'est pas connecté à internet
    QMessageBox.warning(None, 'Avertissement',
                        'Vous n\'êtes actuellement pas connecté à internet. Veuillez vous connecter pour pouvoir utiliser LoaderCEN !')


class Popup(QWidget):
    def __init__(self, parent=None):
        super(Popup, self).__init__(parent)

        self.plugin_dir = os.path.dirname(__file__)

        self.text_edit = QTextBrowser()
        fp = urllib.request.urlopen("https://raw.githubusercontent.com/CEN-Nouvelle-Aquitaine/loaderCEN/main/info_changelog.html")
        mybytes = fp.read()
        html_changelog = mybytes.decode("utf8")
        fp.close()

        self.text_edit.setHtml(html_changelog)
        self.text_edit.setFont(QtGui.QFont("Calibri",weight=QtGui.QFont.Bold))
        self.text_edit.anchorClicked.connect(QtGui.QDesktopServices.openUrl)
        self.text_edit.setOpenLinks(False)

        self.text_edit.setWindowTitle("Nouveautés")
        self.text_edit.setMinimumSize(600,300)

class LoaderCEN:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):

        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'LoaderCEN_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&LoaderCEN')
        self.dlg = LoaderCENDialog()

        self.plugin_path = os.path.dirname(__file__)

        self.RelativePath = Path(__file__).parent.resolve()

        self.movie = QMovie(str(self.RelativePath) + "/loading.gif")  # récupération du gif via le chemin relatif du plugin
        self.dlg.label_3.setMovie(self.movie)
        self.dlg.label_2.setMovie(self.movie)
        self.dlg.label_10.setMovie(self.movie)
        self.dlg.label_12.setMovie(self.movie)
        self.dlg.label_15.setMovie(self.movie)

        self.movie.start()

        self.dlg.label_2.hide()
        self.dlg.label_3.hide()
        self.dlg.label_10.hide()
        self.dlg.label_12.hide()
        self.dlg.label_15.hide()

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads

        self.first_start = None

        self.dlg.comboBox.currentIndexChanged.connect(self.chargement_dalles_MNT)

        self.dlg.commandLinkButton.clicked.connect(self.popup)

        self.dlg.commandLinkButton_2.clicked.connect(self.chargement_dalles_orthos_20cm)

        self.dlg.pushButton.clicked.connect(self.chargement_MNT_1m)

        self.dlg.pushButton_2.clicked.connect(self.orthos)

        self.dlg.pushButton_3.clicked.connect(self.chargement_cadastre)

        self.dlg.comboBox_2.currentIndexChanged.connect(self.emprise_drone)

        self.dlg.pushButton_4.clicked.connect(self.chargement_drone)

        self.dlg.commandLinkButton_4.clicked.connect(self.ajout_metadata_mnt)

        self.dlg.comboBox_3.currentIndexChanged.connect(self.verif_memoire_libre)

        self.dlg.pushButton_5.clicked.connect(self.chargement_lidar)


        self.autocompletion_communes()

        #dossier_dalles = 'https://sig.dsi-cen.org/qgis/downloads/dalles_mnt_1m/'
        #dalles_dept = [fname for fname in os.listdir(dossier_dalles) if fname.endswith('.geojson')]

        dalles_dept = ["Allier", "Charente", "Charente-Maritime", "Corrèze", "Creuse", "Deux-Sevres", "Dordogne", "Gironde", "Haute-Vienne", "Landes", "Lot-et-Garonne", "Pyrénées-Atlantiques", "Vienne"]
        self.dlg.comboBox.addItems(set(dalles_dept))
        
        dalles_lidar_dept = ['Charente','Charente-Maritime','Corrèze','Creuse','Dordogne','Gironde','Haute-Vienne','Landes','Lot-et-Garonne','Pyrénées-Atlantiques']
        
        self.dlg.comboBox_3.addItems(set(dalles_lidar_dept))

        self.dlg.comboBox_2.addItems(set(['16','17','19','23','24','33','40','47','64','79','86','87']))

        metadonnees_plugin = open(self.plugin_dir + '/metadata.txt')
        infos_metadonnees = metadonnees_plugin.readlines()

        derniere_version = urllib.request.urlopen("https://sig.dsi-cen.org/qgis/downloads/last_version_loadercen.txt")
        num_last_version = derniere_version.readlines()[0].decode("utf-8")


        version_utilisateur = infos_metadonnees[8].splitlines()

        if infos_metadonnees[8].splitlines() == num_last_version.splitlines():
            iface.messageBar().pushMessage("Plugin à jour", "Votre version de LoaderCEN %s est à jour !" %version_utilisateur, level=Qgis.Success, duration=5)
        else:
            iface.messageBar().pushMessage("Information :", "Une nouvelle version de LoaderCEN est disponible, veuillez mettre à jour le plugin !", level=Qgis.Info, duration=120)

        with tempfile.TemporaryDirectory() as self.tmpdirname:
            print('le dossier temporaire a été crée', self.tmpdirname)

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('LoaderCEN', message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/LoaderCEN/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'LoaderCEN'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&LoaderCEN'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass

    def chargement_dalles_MNT(self):

        if self.dlg.comboBox.currentText() == "Choix du département":
            QMessageBox.question(self.iface.mainWindow(), u"Choix du département", u"Veuillez sélectionner un département afin de charger le dallage MNT 1 mètre associé !", QMessageBox.Ok)

        else:
            for lyr in QgsProject.instance().mapLayers().values():

                if lyr.name() == "dalles_MNT_1_m":
                    QgsProject.instance().removeMapLayers([lyr.id()])

        
            dalles_MNT = self.iface.addVectorLayer('https://sig.dsi-cen.org/qgis/downloads/dalles_mnt_1m/' + self.dlg.comboBox.currentText() + '.geojson', 'dalles_MNT_1_m', 'ogr')

            mySymbol1 = QgsFillSymbol.createSimple({'color': '#0000ffff',
                                                    'color_border': '#22222',
                                                    'width_border': '0.3'})

            myRenderer = dalles_MNT.renderer()

            myRenderer.setSymbol(mySymbol1)

            dalles_MNT.triggerRepaint()

            ex = dalles_MNT.extent()
            iface.mapCanvas().setExtent(ex)

            self.dlg.commandLinkButton_4.setEnabled(True)

    def ajout_metadata_mnt(self):

        vectorLyr = QgsProject.instance().mapLayersByName("dalles_MNT_1_m")[0]

        csvFilePath = os.path.join(self.plugin_dir, 'loadercen_metadata.csv').replace('\\', '/')
        uri = 'file:///' + csvFilePath + '?delimiter=;'

        url_open = urllib.request.urlopen("https://raw.githubusercontent.com/CEN-Nouvelle-Aquitaine/loadercen/main/loadercen_metadata.csv")


        # Load the CSV file as a delimited text layer
        infoLyr = QgsVectorLayer(uri, "Métadonnées_MNT_LoaderCEN", "delimitedtext")

        if not QgsProject.instance().mapLayersByName("Métadonnées_MNT_LoaderCEN"):
            QgsProject.instance().addMapLayer(infoLyr)
        else:
            infoLyr = QgsProject.instance().mapLayersByName("Métadonnées_MNT_LoaderCEN")[0]

        #headers_csv = [field.name() for field in infoLyr.fields()]
        #headers_shp = [field.name() for field in vectorLyr.fields()]
        #print(headers_csv[0])
        #print(headers_shp[0])

        # Perform the join operation
        joinLayer = QgsVectorLayerJoinInfo()
        joinLayer.setJoinLayerId(infoLyr.id())
        joinLayer.setJoinFieldName('NOM_DALLE')  # Name of the join field in the CSV
        joinLayer.setTargetFieldName('NOM_DALLE')  # Name of the join field in the target layer
        joinLayer.setUsingMemoryCache(True)
        joinLayer.setJoinLayer(infoLyr)
        vectorLyr.addJoin(joinLayer)

        field_name = 'Métadonnées_MNT_LoaderCEN_origine'
        field_index = vectorLyr.fields().indexFromName(field_name)
        unique_values = vectorLyr.uniqueValues(field_index)

        category_list = []
        for value in unique_values:
            symbol = QgsSymbol.defaultSymbol(vectorLyr.geometryType())
            category = QgsRendererCategory(value, symbol, str(value))
            category_list.append(category)

        renderer = QgsCategorizedSymbolRenderer(field_name, category_list)
        renderer.updateColorRamp(QgsRandomColorRamp())
        vectorLyr.setRenderer(renderer)
        vectorLyr.triggerRepaint()


    def chargement_dalles_orthos_20cm(self):

        dalles_orthos_20cm =self.iface.addVectorLayer('https://sig.dsi-cen.org/qgis/downloads/dalles_ortho_20cm.geojson', 'dalles_ortho_20cm', 'ogr')

        for lyr in QgsProject.instance().mapLayers().values():
            if lyr.name() == "dalles_ortho_50cm":
                QgsProject.instance().removeMapLayers([lyr.id()])

        mySymbol1 = QgsFillSymbol.createSimple({'color': '#0000ffff',
                                                'color_border': '#22222',
                                                'width_border': '0.3'})

        myRenderer = dalles_orthos_20cm.renderer()

        myRenderer.setSymbol(mySymbol1)

        dalles_orthos_20cm.triggerRepaint()

    def chargement_MNT_1m(self):

        self.dlg.label_2.show()
        self.dlg.label_3.show()
        self.dlg.label_10.show()
        self.dlg.label_12.show()
        self.dlg.label_15.show()

        dossier_MNT = 'http://51.91.38.98/rgealti/'

        liste_couches = []

        if QgsProject.instance().mapLayersByName('dalles_MNT_1_m'):

            self.dalles_mnt = QgsProject.instance().mapLayersByName('dalles_MNT_1_m')[0]

            if len(self.dalles_mnt.selectedFeatures()) == 0:
                QMessageBox.question(self.iface.mainWindow(), u"Aucune dalle sélectionnée", u"Veuillez sélectionner une dalle depuis QGIS avant de tenter de charger le fichier associé !", QMessageBox.Ok)

            else:

                for f in self.dalles_mnt.selectedFeatures():
                    # refer to a specific values of a field index
                    NOM_COUCHE = f.attribute(0).replace('1-0_MNT_EXT', 'FXX').split('LAMB93_IGN69', 1)[0]+'MNT_LAMB93_IGN69'  # results in Group 1
                    liste_couches.append(NOM_COUCHE)

                if len(liste_couches) > 25:
                    self.QMBquestion = QMessageBox.question(iface.mainWindow(), u"Attention", "Pour des soucis de performances, le nombre de fichiers à charger en simultané est limité à 16.", QMessageBox.Ok)
                    if self.QMBquestion == QMessageBox.Ok:
                        print("Sélectionner moins de 25 dalles à la fois")
                
                else:
                    for couches in liste_couches:
                        alg_params = {
                            'DATA': '',
                            'METHOD': 0,  # GET
                            'OUTPUT': self.tmpdirname + str(couches),
                            'URL': dossier_MNT + str(couches) + '.asc'
                        }
                        processing.run('native:filedownloader', alg_params)
                        iface.addRasterLayer(self.tmpdirname + str(couches), str(couches))
                        print(couches)
        else:
            QMessageBox.question(self.iface.mainWindow(), u"Aucune couche 'dalles_MNT_1_m' détectée", u"Veuillez charger la couche 'dalles_MNT_1_m' depuis le menu 'choix des dalles' pour continuer.", QMessageBox.Ok)


        self.dlg.label_2.hide()
        self.dlg.label_3.hide()
        self.dlg.label_10.hide()
        self.dlg.label_12.hide()
        self.dlg.label_15.hide()

    def orthos(self):

        self.dlg.label_2.show()
        self.dlg.label_3.show()
        self.dlg.label_10.show()
        self.dlg.label_12.show()
        self.dlg.label_15.show()

        liste_couches = []

        if QgsProject.instance().mapLayersByName('dalles_ortho_50cm') or QgsProject.instance().mapLayersByName('dalles_ortho_20cm'):


            if QgsProject.instance().mapLayersByName('dalles_ortho_50cm'):
                self.dalles_ortho = QgsProject.instance().mapLayersByName('dalles_ortho_50cm')[0]
                dossier_orthos = 'http://51.91.38.98/bdortho/50cm/'
            elif QgsProject.instance().mapLayersByName('dalles_ortho_20cm'):
                self.dalles_ortho = QgsProject.instance().mapLayersByName('dalles_ortho_20cm')[0]
                dossier_orthos = 'http://51.91.38.98/bdortho/20cm/'


            if len(self.dalles_ortho.selectedFeatures()) == 0:
                QMessageBox.question(self.iface.mainWindow(), u"Aucune dalle sélectionnée", u"Veuillez sélectionner une dalle depuis QGIS avant de tenter de charger le fichier associé !", QMessageBox.Ok)

            else:

                for f in self.dalles_ortho.selectedFeatures():
                    # refer to a specific values of a field index
                    NOM_COUCHE = f.attribute(0)  # results in Group 1
                    NOM_COUCHE = NOM_COUCHE[2:]
                    liste_couches.append(NOM_COUCHE)

                if len(liste_couches) > 4:
                    self.QMBquestion = QMessageBox.question(iface.mainWindow(), u"Attention", "Pour des soucis de performances, le nombre de fichiers à charger en simultané est limité à 9.", QMessageBox.Ok)
                    if self.QMBquestion == QMessageBox.Ok:
                        print("Sélectionner moins de 15 dalles à la fois")

                else:

                    for couches in liste_couches:
                        alg_params = {
                            'DATA': '',
                            'METHOD': 0,  # GET
                            'OUTPUT': self.tmpdirname + str(couches),
                            'URL': dossier_orthos + str(couches)
                        }
                        processing.run('native:filedownloader', alg_params)

                        iface.addRasterLayer(self.tmpdirname + str(couches), str(couches))
                        print(couches)

                    print("TADAM")
        else:
            QMessageBox.question(self.iface.mainWindow(), u"Aucune couche 'dalles_ortho' détectée", u"Veuillez sélectionner l'une des deux couches 'dalles_orthos' dans le menu 'choix des dalles' pour continuer.", QMessageBox.Ok)

        self.dlg.label_2.hide()
        self.dlg.label_3.hide()
        self.dlg.label_10.hide()
        self.dlg.label_12.hide()
        self.dlg.label_15.hide()


    def autocompletion_communes(self):
        wfs_url = "https://opendata.cen-nouvelle-aquitaine.org/administratif/wfs"
        layer_type = "administratif:cheflieu"

        # Start measuring time for layer loading
        start_time = time.time()

        # Connexion au service WFS
        uri = f"{wfs_url}?VERSION=1.0.0&TYPENAME={layer_type}&request=GetFeature"
        layer = QgsVectorLayer(uri, "Chef Lieu", "WFS")

        # Calculate time taken for layer loading
        load_time = time.time() - start_time

        if not layer.isValid():
            print("Problème avec la couche")
        else:
            print("Couche bien chargée")

        # Start measuring time for concatenating fields and storing them into the list
        start_time = time.time()

        communesList = []  # Utilisation de liste pour stocker les valeurs uniques

        for feature in layer.getFeatures():
            field2_value = feature.attributes()[2]
            field3_value = feature.attributes()[3]
            communesList.append((field3_value, field2_value))  # Append a tuple of (commune, INSEE code)

        # Calculate time taken for concatenation and storing into the list
        concat_time = time.time() - start_time

        # Output time taken
        print(f"Temps de chargement de la couche : {load_time} secondes")
        print(f"Temps de concaténation et de stockage dans la liste : {concat_time} secondes")

        # Create a list of communes for the QCompleter
        commune_names = [f"{commune} ({insee})" for commune, insee in communesList]

        # Create a QCompleter with the list of commune names
        completer = QCompleter(commune_names)
        completer.setCaseSensitivity(Qt.CaseInsensitive)
        completer.setFilterMode(Qt.MatchContains)
        completer.setCompletionMode(QCompleter.PopupCompletion)
        completer.setMaxVisibleItems(10)

        # Set the completer to the lineEdit
        self.dlg.lineEdit.setCompleter(completer)



    def chargement_cadastre(self):

        self.dlg.label_2.show()
        self.dlg.label_3.show()
        self.dlg.label_10.show()
        self.dlg.label_12.show()
        self.dlg.label_15.show()

        # Use search() to find the first match of the pattern
        numero_dept_match = re.search(r'\((\d{2})\d*\)', self.dlg.lineEdit.completer().currentCompletion())

        if numero_dept_match:
            numero_dept = numero_dept_match.group(1)
            print(numero_dept)
        else:
            print("Le numéro de departement n'existe pas dans la liste.")

        selected_commune_match = re.search(r'\((.*?)\)', self.dlg.lineEdit.completer().currentCompletion())

        if selected_commune_match:
            selected_commune = selected_commune_match.group(1)
            print(selected_commune)
        else:
            print("La commune sélectionnée n'existe pas dans la liste.")

        uri = "https://opendata.cen-nouvelle-aquitaine.org/administratif/wfs?VERSION=1.0.0&TYPENAME=administratif:parcelle_", numero_dept, "&SRSNAME=EPSG:4326&request=GetFeature&cql_filter=commune='", selected_commune, "'"
        uri = "".join(uri)

        print(uri)

        cadastre = QgsVectorLayer(uri, self.dlg.lineEdit.text(), "WFS")

        QgsProject.instance().addMapLayer(cadastre)

        nom_couche = "parcelles_cadastrales_commune_" + self.dlg.lineEdit.text()

        cadastre.setName(nom_couche)
        # print(cadastre.extent())
        # Find out if we need to transform coordinates
        proj = QgsProject.instance()
        if cadastre.crs().authid() != proj.crs().authid():
            print("La couche 'cadastre' et le projet QGIS ne partagent pas le même CRS", cadastre.crs().authid(), proj.crs().authid())
            tr = QgsCoordinateTransform(cadastre.crs(), proj.crs(), proj)
            ex = tr.transform(cadastre.extent())

            iface.mapCanvas().setExtent(ex)
            iface.mapCanvas().refresh()
        else:
            iface.mapCanvas().setExtent(cadastre.extent())


        iface.mapCanvas().refresh()

        # # if cadastre.featureCount() == 0:
        #     print(cadastre.featureCount())
        #     QMessageBox.question(self.iface.mainWindow(), u"Couche vide", u"Code Insee inconnu ! ", QMessageBox.Ok)

        # layermap = proj.mapLayers()
        # RemoveLayers = []
        # for name, layer in layermap.items():
        #     if layer.isValid():
        #         if layer.type() == QgsMapLayer.VectorLayer:
        #             if layer.featureCount() == 0:
        #                 RemoveLayers.append(layer.id())
        # if len(RemoveLayers) > 0:
        #     proj.instance().removeMapLayers(RemoveLayers)


        self.dlg.label_2.hide()
        self.dlg.label_3.hide()
        self.dlg.label_10.hide()
        self.dlg.label_12.hide()
        self.dlg.label_15.hide()



    def emprise_drone(self):

        for lyr in QgsProject.instance().mapLayers().values():
            if lyr.name() == "Emprise images drone":
                QgsProject.instance().removeMapLayers([lyr.id()])

        managerAU = QgsApplication.authManager()
        k = managerAU.availableAuthMethodConfigs().keys()

        uri = ["https://opendata.cen-nouvelle-aquitaine.org/drone/wfs?VERSION=1.0.0&TYPENAME=drone:emprise_ortho_drone_CEN_NA&authcfg=", list(k)[0] ,"&request=GetFeature"]
        uri = "".join(uri)

        self.emprise_drone = QgsVectorLayer(uri, "Emprise images drone", "WFS")

        self.emprise_drone.selectByExpression("\"dept\" IS '{0}'".format(self.dlg.comboBox_2.currentText()))

        QgsProject.instance().addMapLayer(self.emprise_drone)

        styles_url = 'https://raw.githubusercontent.com/CEN-Nouvelle-Aquitaine/fluxcen/main/styles_couches/emprise_drone.qml'

        fp = urllib.request.urlopen(styles_url)
        mybytes = fp.read()

        document = QDomDocument()
        document.setContent(mybytes)

        res = self.emprise_drone.importNamedStyle(document)
        self.emprise_drone.triggerRepaint()


        iface.mapCanvas().zoomToSelected(self.emprise_drone)

        iface.mapCanvas().refresh()


        if self.emprise_drone.selectedFeatureCount() == 0:
            print(self.emprise_drone.featureCount())
            QMessageBox.question(self.iface.mainWindow(), u"Données non disponibles", u"Aucune données drone enregistrées sur ce département", QMessageBox.Ok)

        self.emprise_drone.removeSelection()




    def chargement_drone(self):

        if len(self.emprise_drone.selectedFeatures()) == 0:
            QMessageBox.question(self.iface.mainWindow(), u"Aucune emprise drone sélectionnée",
                                 u"Veuillez sélectionner au moins une emprise depuis QGIS avant de tenter de charger l'image drone associée !",
                                 QMessageBox.Ok)

        else:

            self.dlg.label_2.show()
            self.dlg.label_3.show()
            self.dlg.label_10.show()
            self.dlg.label_12.show()
            self.dlg.label_15.show()

            for feature in self.emprise_drone.selectedFeatures():
                image_drone = feature['nomcouche']

                uri = "url=https://opendata.cen-nouvelle-aquitaine.org/geoserver/drone/wms&service=WMS+Raster&version=1.0.0&crs=EPSG:2154&format=image/png&layers=",image_drone,"&styles"
                uri = "".join(uri)

                rlayer = QgsRasterLayer(uri, image_drone, "WMS")
                QgsProject.instance().addMapLayer(rlayer)

            self.dlg.label_2.hide()
            self.dlg.label_3.hide()
            self.dlg.label_10.hide()
            self.dlg.label_12.hide()
            self.dlg.label_15.hide()

            iface.mapCanvas().zoomToSelected(self.emprise_drone)

            self.emprise_drone.removeSelection()


    def verif_memoire_libre(self):

        if platform.system() == "Windows":
            chemin_disque = "C:/"

            # statistiques mémoire sur disque C:
            stat = shutil.disk_usage(chemin_disque)

            # Conversion en gigabytes pour une meilleure lisibilité
            # total_gb_windows = stat.total / (1024 ** 3)
            # used_gb_windows = stat.used / (1024 ** 3)
            free_gb_windows = stat.free / (1024 ** 3)
            
            if free_gb_windows < 5:
                QMessageBox.question(
                    self.iface.mainWindow(),
                    u"Espace disque libre faible",
                    u"Vous avez moins de 5Go de libres sur votre disque dur, veuillez libérer de l'espace disque pour pouvoir charger les données Lidar depuis LoaderCEN !",
                    QMessageBox.Ok
                )

                return
            
                # print("Disk usage statistics:")
                # print(f'Espace total: {total_gb_windows:.2f} Go')
                # print(f'Espace utilisé: {used_gb_windows:.2f} Gp')
                # print(f'Espace libre: {free_gb_windows:.2f} Go')

            else:
                self.chargement_dalles_lidar()

        else:
            total, used, free = shutil.disk_usage("/")
            free_gb_linux = free // (2**30)
            
            if free_gb_linux < 5:
                QMessageBox.question(
                    self.iface.mainWindow(),
                    u"Espace disque libre faible",
                    u"Vous avez moins de 5Go de libres sur votre disque dur, veuillez libérer de l'espace disque pour pouvoir charger les données Lidar depuis LoaderCEN !",
                    QMessageBox.Ok
                )
                return
            else:
                self.chargement_dalles_lidar()


    def chargement_dalles_lidar(self):

        if self.dlg.comboBox_3.currentText() == "Choix du département":
            QMessageBox.question(self.iface.mainWindow(), u"Choix du département", u"Veuillez sélectionner un département afin de charger le dallage Lidar associé !", QMessageBox.Ok)

        else:
            for lyr in QgsProject.instance().mapLayers().values():

                if lyr.name() == "Dalles Lidar":
                    QgsProject.instance().removeMapLayers([lyr.id()])

        # Create a vector layer from the GeoJSON file
        dalles_lidar = QgsVectorLayer('https://sig.dsi-cen.org/qgis/downloads/dalles_lidar.geojson', 'Dalles Lidar', 'ogr')

        # Check if the layer was loaded successfully
        if not dalles_lidar.isValid():
            print('Layer failed to load!')

        dalles_lidar.setSubsetString('nom_dep=\'' + self.dlg.comboBox_3.currentText() + '\'')

        # Add the layer to the map
        QgsProject.instance().addMapLayer(dalles_lidar)


        mySymbol1 = QgsFillSymbol.createSimple({'color': '#0000ffff',
                                                'color_border': '#22222',
                                                'width_border': '0.3'})

        myRenderer = dalles_lidar.renderer()

        myRenderer.setSymbol(mySymbol1)

        dalles_lidar.triggerRepaint()

        ex = dalles_lidar.extent()
        iface.mapCanvas().setExtent(ex)

    def chargement_lidar(self):

        self.dalles_lidar = QgsProject.instance().mapLayersByName('Dalles Lidar')[0]


        if len(self.dalles_lidar.selectedFeatures()) == 0:
            QMessageBox.question(self.iface.mainWindow(), u"Aucune emprise drone sélectionnée", u"Veuillez sélectionner au moins une dalle Lidar depuis QGIS avant de tenter de charger les données associées !", QMessageBox.Ok)
            return
        elif self.dalles_lidar.selectedFeatureCount() > 4:
            self.QMBquestion = QMessageBox.question(self.iface.mainWindow(), u"Attention", "Pour des soucis de performances, le nombre de fichiers Lidar à charger en simultané est limité à 4.", QMessageBox.Ok)
            return
        else:

            self.dlg.label_2.show()
            self.dlg.label_3.show()
            self.dlg.label_10.show()
            self.dlg.label_12.show()
            self.dlg.label_15.show()

            self.dalles_lidar = QgsProject.instance().mapLayersByName('Dalles Lidar')[0]

            selected_dalles_lidar = self.dalles_lidar.selectedFeatures()

            if selected_dalles_lidar:

                for feature in selected_dalles_lidar:
                    nom_dalle = feature.attributes()[0]
                    url_dalle = feature.attributes()[1]
                    print("Nom de la dalle:", nom_dalle)
                    print("Url de la dalle:", url_dalle)

                    # Create a QgsPointCloudLayer instance (native LAS provider)
                    point_cloud_layer = QgsPointCloudLayer(uri=url_dalle, baseName=nom_dalle, providerLib="copc")

                    # Add the point cloud layer to the map
                    QgsProject.instance().addMapLayer(point_cloud_layer)
            else:
                print("No features selected.")



            self.dlg.label_2.hide()
            self.dlg.label_3.hide()
            self.dlg.label_10.hide()
            self.dlg.label_12.hide()
            self.dlg.label_15.hide()

            iface.mapCanvas().zoomToSelected(point_cloud_layer)

            self.dalles_lidar.removeSelection()


    def popup(self):

        self.dialog = Popup()  # +++ - self
        self.dialog.text_edit.show()